/*
 * Sia
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.3.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.goobox.sync.sia.client.api;

import io.goobox.sync.sia.client.ApiCallback;
import io.goobox.sync.sia.client.ApiClient;
import io.goobox.sync.sia.client.ApiException;
import io.goobox.sync.sia.client.ApiResponse;
import io.goobox.sync.sia.client.Configuration;
import io.goobox.sync.sia.client.Pair;
import io.goobox.sync.sia.client.ProgressRequestBody;
import io.goobox.sync.sia.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import io.goobox.sync.sia.client.api.model.InlineResponse2004;
import io.goobox.sync.sia.client.api.model.InlineResponse2005;
import io.goobox.sync.sia.client.api.model.StandardError;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HostApi {
    private ApiClient apiClient;

    public HostApi() {
        this(Configuration.getDefaultApiClient());
    }

    public HostApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /**
     * Build call for hostAnnouncePost
     * @param netaddress The address to be announced. If no address is provided, the automatically discovered address will be used instead. (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostAnnouncePostCall(String netaddress, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/announce";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (netaddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("netaddress", netaddress));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostAnnouncePostValidateBeforeCall(String netaddress, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = hostAnnouncePostCall(netaddress, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * Announce the host to the network as a source of storage. Generally only needs to be called once.
     * @param netaddress The address to be announced. If no address is provided, the automatically discovered address will be used instead. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostAnnouncePost(String netaddress) throws ApiException {
        hostAnnouncePostWithHttpInfo(netaddress);
    }

    /**
     * 
     * Announce the host to the network as a source of storage. Generally only needs to be called once.
     * @param netaddress The address to be announced. If no address is provided, the automatically discovered address will be used instead. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostAnnouncePostWithHttpInfo(String netaddress) throws ApiException {
        com.squareup.okhttp.Call call = hostAnnouncePostValidateBeforeCall(netaddress, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * Announce the host to the network as a source of storage. Generally only needs to be called once.
     * @param netaddress The address to be announced. If no address is provided, the automatically discovered address will be used instead. (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostAnnouncePostAsync(String netaddress, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostAnnouncePostValidateBeforeCall(netaddress, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for hostGet
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostGetCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostGetValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = hostGetCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * fetches status information about the host
     * @return InlineResponse2004
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public InlineResponse2004 hostGet() throws ApiException {
        ApiResponse<InlineResponse2004> resp = hostGetWithHttpInfo();
        return resp.getData();
    }

    /**
     * 
     * fetches status information about the host
     * @return ApiResponse&lt;InlineResponse2004&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<InlineResponse2004> hostGetWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = hostGetValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<InlineResponse2004>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * fetches status information about the host
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostGetAsync(final ApiCallback<InlineResponse2004> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostGetValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InlineResponse2004>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for hostPost
     * @param acceptingcontracts When set to true, the host will accept new file contracts if the terms are reasonable. When set to false, the host will not accept new file contracts at all.  (optional)
     * @param maxdownloadbatchsize The maximum size of a single download request from a renter. Each download request has multiple round trips of communication that exchange money. Larger batch sizes mean fewer round trips, but more financial risk for the host - the renter can get a free batch when downloading by refusing to provide a signature.  (optional)
     * @param maxduration The maximum duration of a file contract that the host will accept. The storage proof window must end before the current height + maxduration.  (optional)
     * @param maxrevisebatchsize The maximum size of a single batch of file contract revisions. The renter can perform DoS attacks on the host by uploading a batch of data then refusing to provide a signature to pay for the data. The host can reduce this exposure by limiting the batch size. Larger batch sizes allow for higher throughput as there is significant communication overhead associated with performing a batch upload.  (optional)
     * @param netaddress The IP address or hostname (including port) that the host should be contacted at. If left blank, the host will automatically figure out its ip address and use that. If given, the host will use the address given.  (optional)
     * @param windowsize The storage proof window is the number of blocks that the host has to get a storage proof onto the blockchain. The window size is the minimum size of window that the host will accept in a file contract.  (optional)
     * @param collateral The maximum amount of money that the host will put up as collateral per byte per block of storage that is contracted by the renter. (optional)
     * @param collateralbudget The total amount of money that the host will allocate to collateral across all file contracts. (optional)
     * @param maxcollateral The maximum amount of collateral that the host will put into a single file contract. (optional)
     * @param mincontractprice The minimum price that the host will demand from a renter when forming a contract. Typically this price is to cover transaction fees on the file contract revision and storage proof, but can also be used if the host has a low amount of collateral. The price is a minimum because the host may automatically adjust the price upwards in times of high demand.  (optional)
     * @param mindownloadbandwidthprice The minimum price that the host will demand from a renter when the renter is downloading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param minstorageprice The minimum price that the host will demand when storing data for extended periods of time. If the host is low on space, the price of storage may be set higher than the minimum.  (optional)
     * @param minuploadbandwidthprice The minimum price that the host will demand from a renter when the renter is uploading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostPostCall(Boolean acceptingcontracts, String maxdownloadbatchsize, String maxduration, String maxrevisebatchsize, String netaddress, String windowsize, String collateral, String collateralbudget, String maxcollateral, String mincontractprice, String mindownloadbandwidthprice, String minstorageprice, String minuploadbandwidthprice, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (acceptingcontracts != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("acceptingcontracts", acceptingcontracts));
        if (maxdownloadbatchsize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxdownloadbatchsize", maxdownloadbatchsize));
        if (maxduration != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxduration", maxduration));
        if (maxrevisebatchsize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxrevisebatchsize", maxrevisebatchsize));
        if (netaddress != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("netaddress", netaddress));
        if (windowsize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("windowsize", windowsize));
        if (collateral != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("collateral", collateral));
        if (collateralbudget != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("collateralbudget", collateralbudget));
        if (maxcollateral != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("maxcollateral", maxcollateral));
        if (mincontractprice != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("mincontractprice", mincontractprice));
        if (mindownloadbandwidthprice != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("mindownloadbandwidthprice", mindownloadbandwidthprice));
        if (minstorageprice != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("minstorageprice", minstorageprice));
        if (minuploadbandwidthprice != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("minuploadbandwidthprice", minuploadbandwidthprice));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostPostValidateBeforeCall(Boolean acceptingcontracts, String maxdownloadbatchsize, String maxduration, String maxrevisebatchsize, String netaddress, String windowsize, String collateral, String collateralbudget, String maxcollateral, String mincontractprice, String mindownloadbandwidthprice, String minstorageprice, String minuploadbandwidthprice, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = hostPostCall(acceptingcontracts, maxdownloadbatchsize, maxduration, maxrevisebatchsize, netaddress, windowsize, collateral, collateralbudget, maxcollateral, mincontractprice, mindownloadbandwidthprice, minstorageprice, minuploadbandwidthprice, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * configures hosting parameters. All parameters are optional; unspecified parameters will be left unchanged.
     * @param acceptingcontracts When set to true, the host will accept new file contracts if the terms are reasonable. When set to false, the host will not accept new file contracts at all.  (optional)
     * @param maxdownloadbatchsize The maximum size of a single download request from a renter. Each download request has multiple round trips of communication that exchange money. Larger batch sizes mean fewer round trips, but more financial risk for the host - the renter can get a free batch when downloading by refusing to provide a signature.  (optional)
     * @param maxduration The maximum duration of a file contract that the host will accept. The storage proof window must end before the current height + maxduration.  (optional)
     * @param maxrevisebatchsize The maximum size of a single batch of file contract revisions. The renter can perform DoS attacks on the host by uploading a batch of data then refusing to provide a signature to pay for the data. The host can reduce this exposure by limiting the batch size. Larger batch sizes allow for higher throughput as there is significant communication overhead associated with performing a batch upload.  (optional)
     * @param netaddress The IP address or hostname (including port) that the host should be contacted at. If left blank, the host will automatically figure out its ip address and use that. If given, the host will use the address given.  (optional)
     * @param windowsize The storage proof window is the number of blocks that the host has to get a storage proof onto the blockchain. The window size is the minimum size of window that the host will accept in a file contract.  (optional)
     * @param collateral The maximum amount of money that the host will put up as collateral per byte per block of storage that is contracted by the renter. (optional)
     * @param collateralbudget The total amount of money that the host will allocate to collateral across all file contracts. (optional)
     * @param maxcollateral The maximum amount of collateral that the host will put into a single file contract. (optional)
     * @param mincontractprice The minimum price that the host will demand from a renter when forming a contract. Typically this price is to cover transaction fees on the file contract revision and storage proof, but can also be used if the host has a low amount of collateral. The price is a minimum because the host may automatically adjust the price upwards in times of high demand.  (optional)
     * @param mindownloadbandwidthprice The minimum price that the host will demand from a renter when the renter is downloading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param minstorageprice The minimum price that the host will demand when storing data for extended periods of time. If the host is low on space, the price of storage may be set higher than the minimum.  (optional)
     * @param minuploadbandwidthprice The minimum price that the host will demand from a renter when the renter is uploading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostPost(Boolean acceptingcontracts, String maxdownloadbatchsize, String maxduration, String maxrevisebatchsize, String netaddress, String windowsize, String collateral, String collateralbudget, String maxcollateral, String mincontractprice, String mindownloadbandwidthprice, String minstorageprice, String minuploadbandwidthprice) throws ApiException {
        hostPostWithHttpInfo(acceptingcontracts, maxdownloadbatchsize, maxduration, maxrevisebatchsize, netaddress, windowsize, collateral, collateralbudget, maxcollateral, mincontractprice, mindownloadbandwidthprice, minstorageprice, minuploadbandwidthprice);
    }

    /**
     * 
     * configures hosting parameters. All parameters are optional; unspecified parameters will be left unchanged.
     * @param acceptingcontracts When set to true, the host will accept new file contracts if the terms are reasonable. When set to false, the host will not accept new file contracts at all.  (optional)
     * @param maxdownloadbatchsize The maximum size of a single download request from a renter. Each download request has multiple round trips of communication that exchange money. Larger batch sizes mean fewer round trips, but more financial risk for the host - the renter can get a free batch when downloading by refusing to provide a signature.  (optional)
     * @param maxduration The maximum duration of a file contract that the host will accept. The storage proof window must end before the current height + maxduration.  (optional)
     * @param maxrevisebatchsize The maximum size of a single batch of file contract revisions. The renter can perform DoS attacks on the host by uploading a batch of data then refusing to provide a signature to pay for the data. The host can reduce this exposure by limiting the batch size. Larger batch sizes allow for higher throughput as there is significant communication overhead associated with performing a batch upload.  (optional)
     * @param netaddress The IP address or hostname (including port) that the host should be contacted at. If left blank, the host will automatically figure out its ip address and use that. If given, the host will use the address given.  (optional)
     * @param windowsize The storage proof window is the number of blocks that the host has to get a storage proof onto the blockchain. The window size is the minimum size of window that the host will accept in a file contract.  (optional)
     * @param collateral The maximum amount of money that the host will put up as collateral per byte per block of storage that is contracted by the renter. (optional)
     * @param collateralbudget The total amount of money that the host will allocate to collateral across all file contracts. (optional)
     * @param maxcollateral The maximum amount of collateral that the host will put into a single file contract. (optional)
     * @param mincontractprice The minimum price that the host will demand from a renter when forming a contract. Typically this price is to cover transaction fees on the file contract revision and storage proof, but can also be used if the host has a low amount of collateral. The price is a minimum because the host may automatically adjust the price upwards in times of high demand.  (optional)
     * @param mindownloadbandwidthprice The minimum price that the host will demand from a renter when the renter is downloading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param minstorageprice The minimum price that the host will demand when storing data for extended periods of time. If the host is low on space, the price of storage may be set higher than the minimum.  (optional)
     * @param minuploadbandwidthprice The minimum price that the host will demand from a renter when the renter is uploading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostPostWithHttpInfo(Boolean acceptingcontracts, String maxdownloadbatchsize, String maxduration, String maxrevisebatchsize, String netaddress, String windowsize, String collateral, String collateralbudget, String maxcollateral, String mincontractprice, String mindownloadbandwidthprice, String minstorageprice, String minuploadbandwidthprice) throws ApiException {
        com.squareup.okhttp.Call call = hostPostValidateBeforeCall(acceptingcontracts, maxdownloadbatchsize, maxduration, maxrevisebatchsize, netaddress, windowsize, collateral, collateralbudget, maxcollateral, mincontractprice, mindownloadbandwidthprice, minstorageprice, minuploadbandwidthprice, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * configures hosting parameters. All parameters are optional; unspecified parameters will be left unchanged.
     * @param acceptingcontracts When set to true, the host will accept new file contracts if the terms are reasonable. When set to false, the host will not accept new file contracts at all.  (optional)
     * @param maxdownloadbatchsize The maximum size of a single download request from a renter. Each download request has multiple round trips of communication that exchange money. Larger batch sizes mean fewer round trips, but more financial risk for the host - the renter can get a free batch when downloading by refusing to provide a signature.  (optional)
     * @param maxduration The maximum duration of a file contract that the host will accept. The storage proof window must end before the current height + maxduration.  (optional)
     * @param maxrevisebatchsize The maximum size of a single batch of file contract revisions. The renter can perform DoS attacks on the host by uploading a batch of data then refusing to provide a signature to pay for the data. The host can reduce this exposure by limiting the batch size. Larger batch sizes allow for higher throughput as there is significant communication overhead associated with performing a batch upload.  (optional)
     * @param netaddress The IP address or hostname (including port) that the host should be contacted at. If left blank, the host will automatically figure out its ip address and use that. If given, the host will use the address given.  (optional)
     * @param windowsize The storage proof window is the number of blocks that the host has to get a storage proof onto the blockchain. The window size is the minimum size of window that the host will accept in a file contract.  (optional)
     * @param collateral The maximum amount of money that the host will put up as collateral per byte per block of storage that is contracted by the renter. (optional)
     * @param collateralbudget The total amount of money that the host will allocate to collateral across all file contracts. (optional)
     * @param maxcollateral The maximum amount of collateral that the host will put into a single file contract. (optional)
     * @param mincontractprice The minimum price that the host will demand from a renter when forming a contract. Typically this price is to cover transaction fees on the file contract revision and storage proof, but can also be used if the host has a low amount of collateral. The price is a minimum because the host may automatically adjust the price upwards in times of high demand.  (optional)
     * @param mindownloadbandwidthprice The minimum price that the host will demand from a renter when the renter is downloading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param minstorageprice The minimum price that the host will demand when storing data for extended periods of time. If the host is low on space, the price of storage may be set higher than the minimum.  (optional)
     * @param minuploadbandwidthprice The minimum price that the host will demand from a renter when the renter is uploading data. If the host is saturated, the host may increase the price from the minimum.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostPostAsync(Boolean acceptingcontracts, String maxdownloadbatchsize, String maxduration, String maxrevisebatchsize, String netaddress, String windowsize, String collateral, String collateralbudget, String maxcollateral, String mincontractprice, String mindownloadbandwidthprice, String minstorageprice, String minuploadbandwidthprice, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostPostValidateBeforeCall(acceptingcontracts, maxdownloadbatchsize, maxduration, maxrevisebatchsize, netaddress, windowsize, collateral, collateralbudget, maxcollateral, mincontractprice, mindownloadbandwidthprice, minstorageprice, minuploadbandwidthprice, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for hostStorageFoldersAddPost
     * @param path Local path on disk to the storage folder to add. (required)
     * @param size Initial capacity of the storage folder. This value isn&#39;t validated so it is possible to set the capacity of the storage folder greater than the capacity of the disk. Do not do this. in: query  (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersAddPostCall(String path, Integer size, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/storage/folders/add";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (size != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("size", size));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostStorageFoldersAddPostValidateBeforeCall(String path, Integer size, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling hostStorageFoldersAddPost(Async)");
        }
        
        // verify the required parameter 'size' is set
        if (size == null) {
            throw new ApiException("Missing the required parameter 'size' when calling hostStorageFoldersAddPost(Async)");
        }
        

        com.squareup.okhttp.Call call = hostStorageFoldersAddPostCall(path, size, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * adds a storage folder to the manager. The manager may not check that there is enough space available on-disk to support as much storage as requested
     * @param path Local path on disk to the storage folder to add. (required)
     * @param size Initial capacity of the storage folder. This value isn&#39;t validated so it is possible to set the capacity of the storage folder greater than the capacity of the disk. Do not do this. in: query  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostStorageFoldersAddPost(String path, Integer size) throws ApiException {
        hostStorageFoldersAddPostWithHttpInfo(path, size);
    }

    /**
     * 
     * adds a storage folder to the manager. The manager may not check that there is enough space available on-disk to support as much storage as requested
     * @param path Local path on disk to the storage folder to add. (required)
     * @param size Initial capacity of the storage folder. This value isn&#39;t validated so it is possible to set the capacity of the storage folder greater than the capacity of the disk. Do not do this. in: query  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostStorageFoldersAddPostWithHttpInfo(String path, Integer size) throws ApiException {
        com.squareup.okhttp.Call call = hostStorageFoldersAddPostValidateBeforeCall(path, size, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * adds a storage folder to the manager. The manager may not check that there is enough space available on-disk to support as much storage as requested
     * @param path Local path on disk to the storage folder to add. (required)
     * @param size Initial capacity of the storage folder. This value isn&#39;t validated so it is possible to set the capacity of the storage folder greater than the capacity of the disk. Do not do this. in: query  (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersAddPostAsync(String path, Integer size, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostStorageFoldersAddPostValidateBeforeCall(path, size, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for hostStorageFoldersRemovePost
     * @param path Local path on disk to the storage folder to remove. (required)
     * @param force If &#x60;force&#x60; is true, the storage folder will be removed even if the data in the storage folder cannot be moved to other storage folders, typically because they don&#39;t have sufficient capacity. If &#x60;force&#x60; is true and the data cannot be moved, data will be lost.  (optional)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersRemovePostCall(String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/storage/folders/remove";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (force != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("force", force));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostStorageFoldersRemovePostValidateBeforeCall(String path, Boolean force, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling hostStorageFoldersRemovePost(Async)");
        }
        

        com.squareup.okhttp.Call call = hostStorageFoldersRemovePostCall(path, force, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * Remove a storage folder from the manager. All storage on the folder will be moved to other storage folders, meaning that no data will be lost. If the manager is unable to save data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to remove. (required)
     * @param force If &#x60;force&#x60; is true, the storage folder will be removed even if the data in the storage folder cannot be moved to other storage folders, typically because they don&#39;t have sufficient capacity. If &#x60;force&#x60; is true and the data cannot be moved, data will be lost.  (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostStorageFoldersRemovePost(String path, Boolean force) throws ApiException {
        hostStorageFoldersRemovePostWithHttpInfo(path, force);
    }

    /**
     * 
     * Remove a storage folder from the manager. All storage on the folder will be moved to other storage folders, meaning that no data will be lost. If the manager is unable to save data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to remove. (required)
     * @param force If &#x60;force&#x60; is true, the storage folder will be removed even if the data in the storage folder cannot be moved to other storage folders, typically because they don&#39;t have sufficient capacity. If &#x60;force&#x60; is true and the data cannot be moved, data will be lost.  (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostStorageFoldersRemovePostWithHttpInfo(String path, Boolean force) throws ApiException {
        com.squareup.okhttp.Call call = hostStorageFoldersRemovePostValidateBeforeCall(path, force, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * Remove a storage folder from the manager. All storage on the folder will be moved to other storage folders, meaning that no data will be lost. If the manager is unable to save data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to remove. (required)
     * @param force If &#x60;force&#x60; is true, the storage folder will be removed even if the data in the storage folder cannot be moved to other storage folders, typically because they don&#39;t have sufficient capacity. If &#x60;force&#x60; is true and the data cannot be moved, data will be lost.  (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersRemovePostAsync(String path, Boolean force, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostStorageFoldersRemovePostValidateBeforeCall(path, force, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for hostStorageFoldersResizePost
     * @param path Local path on disk to the storage folder to resize. (required)
     * @param newsize Desired new size of the storage folder. This will be the new capacity of the storage folder. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersResizePostCall(String path, Integer newsize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/storage/folders/resize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        if (path != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("path", path));
        if (newsize != null)
        localVarQueryParams.addAll(apiClient.parameterToPair("newsize", newsize));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostStorageFoldersResizePostValidateBeforeCall(String path, Integer newsize, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'path' is set
        if (path == null) {
            throw new ApiException("Missing the required parameter 'path' when calling hostStorageFoldersResizePost(Async)");
        }
        
        // verify the required parameter 'newsize' is set
        if (newsize == null) {
            throw new ApiException("Missing the required parameter 'newsize' when calling hostStorageFoldersResizePost(Async)");
        }
        

        com.squareup.okhttp.Call call = hostStorageFoldersResizePostCall(path, newsize, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * grows or shrink a storage folder in the manager. The manager may not check that there is enough space on-disk to support growing the storage folder, but should gracefully handle running out of space unexpectedly. When shrinking a storage folder, any data in the folder that needs to be moved will be placed into other storage folders, meaning that no data will be lost. If the manager is unable to migrate the data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to resize. (required)
     * @param newsize Desired new size of the storage folder. This will be the new capacity of the storage folder. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostStorageFoldersResizePost(String path, Integer newsize) throws ApiException {
        hostStorageFoldersResizePostWithHttpInfo(path, newsize);
    }

    /**
     * 
     * grows or shrink a storage folder in the manager. The manager may not check that there is enough space on-disk to support growing the storage folder, but should gracefully handle running out of space unexpectedly. When shrinking a storage folder, any data in the folder that needs to be moved will be placed into other storage folders, meaning that no data will be lost. If the manager is unable to migrate the data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to resize. (required)
     * @param newsize Desired new size of the storage folder. This will be the new capacity of the storage folder. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostStorageFoldersResizePostWithHttpInfo(String path, Integer newsize) throws ApiException {
        com.squareup.okhttp.Call call = hostStorageFoldersResizePostValidateBeforeCall(path, newsize, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * grows or shrink a storage folder in the manager. The manager may not check that there is enough space on-disk to support growing the storage folder, but should gracefully handle running out of space unexpectedly. When shrinking a storage folder, any data in the folder that needs to be moved will be placed into other storage folders, meaning that no data will be lost. If the manager is unable to migrate the data, an error will be returned and the operation will be stopped. 
     * @param path Local path on disk to the storage folder to resize. (required)
     * @param newsize Desired new size of the storage folder. This will be the new capacity of the storage folder. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostStorageFoldersResizePostAsync(String path, Integer newsize, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostStorageFoldersResizePostValidateBeforeCall(path, newsize, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /**
     * Build call for hostStorageGet
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostStorageGetCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/storage";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostStorageGetValidateBeforeCall(final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        

        com.squareup.okhttp.Call call = hostStorageGetCall(progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * gets a list of folders tracked by the host&#39;s storage manager.
     * @return InlineResponse2005
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public InlineResponse2005 hostStorageGet() throws ApiException {
        ApiResponse<InlineResponse2005> resp = hostStorageGetWithHttpInfo();
        return resp.getData();
    }

    /**
     * 
     * gets a list of folders tracked by the host&#39;s storage manager.
     * @return ApiResponse&lt;InlineResponse2005&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<InlineResponse2005> hostStorageGetWithHttpInfo() throws ApiException {
        com.squareup.okhttp.Call call = hostStorageGetValidateBeforeCall(null, null);
        Type localVarReturnType = new TypeToken<InlineResponse2005>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     *  (asynchronously)
     * gets a list of folders tracked by the host&#39;s storage manager.
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostStorageGetAsync(final ApiCallback<InlineResponse2005> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostStorageGetValidateBeforeCall(progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<InlineResponse2005>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /**
     * Build call for hostStorageSectorsDeleteMerklerootPost
     * @param merkleroot Merkleroot of the sector to delete. (required)
     * @param progressListener Progress listener
     * @param progressRequestListener Progress request listener
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     */
    public com.squareup.okhttp.Call hostStorageSectorsDeleteMerklerootPostCall(String merkleroot, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/host/storage/sectors/delete/{merkleroot}"
            .replaceAll("\\{" + "merkleroot" + "\\}", apiClient.escapeString(merkleroot.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] { "basicAuth" };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call hostStorageSectorsDeleteMerklerootPostValidateBeforeCall(String merkleroot, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'merkleroot' is set
        if (merkleroot == null) {
            throw new ApiException("Missing the required parameter 'merkleroot' when calling hostStorageSectorsDeleteMerklerootPost(Async)");
        }
        

        com.squareup.okhttp.Call call = hostStorageSectorsDeleteMerklerootPostCall(merkleroot, progressListener, progressRequestListener);
        return call;

    }

    /**
     * 
     * deletes a sector, meaning that the manager will be unable to upload that sector and be unable to provide a storage proof on that sector. This endpoint is for removing the data entirely, and will remove instances of the sector appearing at all heights. The primary purpose is to comply with legal requests to remove data. 
     * @param merkleroot Merkleroot of the sector to delete. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void hostStorageSectorsDeleteMerklerootPost(String merkleroot) throws ApiException {
        hostStorageSectorsDeleteMerklerootPostWithHttpInfo(merkleroot);
    }

    /**
     * 
     * deletes a sector, meaning that the manager will be unable to upload that sector and be unable to provide a storage proof on that sector. This endpoint is for removing the data entirely, and will remove instances of the sector appearing at all heights. The primary purpose is to comply with legal requests to remove data. 
     * @param merkleroot Merkleroot of the sector to delete. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> hostStorageSectorsDeleteMerklerootPostWithHttpInfo(String merkleroot) throws ApiException {
        com.squareup.okhttp.Call call = hostStorageSectorsDeleteMerklerootPostValidateBeforeCall(merkleroot, null, null);
        return apiClient.execute(call);
    }

    /**
     *  (asynchronously)
     * deletes a sector, meaning that the manager will be unable to upload that sector and be unable to provide a storage proof on that sector. This endpoint is for removing the data entirely, and will remove instances of the sector appearing at all heights. The primary purpose is to comply with legal requests to remove data. 
     * @param merkleroot Merkleroot of the sector to delete. (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call hostStorageSectorsDeleteMerklerootPostAsync(String merkleroot, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = hostStorageSectorsDeleteMerklerootPostValidateBeforeCall(merkleroot, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
}
