/*
 * Sia
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.3.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.goobox.sync.sia.client.api.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;

/**
 * FileInfo
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-12-01T00:02:50.340-05:00")
public class FileInfo {
  @SerializedName("available")
  private Boolean available = null;

  @SerializedName("expiration")
  private Long expiration = null;

  @SerializedName("filesize")
  private Long filesize = null;

  @SerializedName("localpath")
  private String localpath = null;

  @SerializedName("redundancy")
  private BigDecimal redundancy = null;

  @SerializedName("renewing")
  private Boolean renewing = null;

  @SerializedName("siapath")
  private String siapath = null;

  @SerializedName("uploadedbytes")
  private Long uploadedbytes = null;

  @SerializedName("uploadprogress")
  private BigDecimal uploadprogress = null;

  public FileInfo available(Boolean available) {
    this.available = available;
    return this;
  }

   /**
   * true if the file is available for download. Files may be available before they are completely uploaded.
   * @return available
  **/
  @ApiModelProperty(example = "true", value = "true if the file is available for download. Files may be available before they are completely uploaded.")
  public Boolean isAvailable() {
    return available;
  }

  public void setAvailable(Boolean available) {
    this.available = available;
  }

  public FileInfo expiration(Long expiration) {
    this.expiration = expiration;
    return this;
  }

   /**
   * Block height at which the file ceases availability.
   * @return expiration
  **/
  @ApiModelProperty(example = "60000", value = "Block height at which the file ceases availability.")
  public Long getExpiration() {
    return expiration;
  }

  public void setExpiration(Long expiration) {
    this.expiration = expiration;
  }

  public FileInfo filesize(Long filesize) {
    this.filesize = filesize;
    return this;
  }

   /**
   * Size of the file in bytes.
   * @return filesize
  **/
  @ApiModelProperty(example = "8192", value = "Size of the file in bytes.")
  public Long getFilesize() {
    return filesize;
  }

  public void setFilesize(Long filesize) {
    this.filesize = filesize;
  }

  public FileInfo localpath(String localpath) {
    this.localpath = localpath;
    return this;
  }

   /**
   * Path to the local file on disk.
   * @return localpath
  **/
  @ApiModelProperty(example = "/home/foo/bar.txt", value = "Path to the local file on disk.")
  public String getLocalpath() {
    return localpath;
  }

  public void setLocalpath(String localpath) {
    this.localpath = localpath;
  }

  public FileInfo redundancy(BigDecimal redundancy) {
    this.redundancy = redundancy;
    return this;
  }

   /**
   * Average redundancy of the file on the network. Redundancy is calculated by dividing the amount of data uploaded in the file&#39;s open contracts by the size of the file. Redundancy does not necessarily correspond to availability. Specifically, a redundancy &gt;&#x3D; 1 does not indicate the file is available as there could be a chunk of the file with 0 redundancy.
   * @return redundancy
  **/
  @ApiModelProperty(example = "5.0", value = "Average redundancy of the file on the network. Redundancy is calculated by dividing the amount of data uploaded in the file's open contracts by the size of the file. Redundancy does not necessarily correspond to availability. Specifically, a redundancy >= 1 does not indicate the file is available as there could be a chunk of the file with 0 redundancy.")
  public BigDecimal getRedundancy() {
    return redundancy;
  }

  public void setRedundancy(BigDecimal redundancy) {
    this.redundancy = redundancy;
  }

  public FileInfo renewing(Boolean renewing) {
    this.renewing = renewing;
    return this;
  }

   /**
   * true if the file&#39;s contracts will be automatically renewed by the renter.
   * @return renewing
  **/
  @ApiModelProperty(example = "true", value = "true if the file's contracts will be automatically renewed by the renter.")
  public Boolean isRenewing() {
    return renewing;
  }

  public void setRenewing(Boolean renewing) {
    this.renewing = renewing;
  }

  public FileInfo siapath(String siapath) {
    this.siapath = siapath;
    return this;
  }

   /**
   * Path to the file in the renter on the network.
   * @return siapath
  **/
  @ApiModelProperty(example = "foo/bar.txt", value = "Path to the file in the renter on the network.")
  public String getSiapath() {
    return siapath;
  }

  public void setSiapath(String siapath) {
    this.siapath = siapath;
  }

  public FileInfo uploadedbytes(Long uploadedbytes) {
    this.uploadedbytes = uploadedbytes;
    return this;
  }

   /**
   * Total number of bytes successfully uploaded via current file contracts. This number includes padding and rendundancy, so a file with a size of 8192 bytes might be padded to 40 MiB and, with a redundancy of 5, encoded to 200 MiB for upload.
   * @return uploadedbytes
  **/
  @ApiModelProperty(example = "209715200", value = "Total number of bytes successfully uploaded via current file contracts. This number includes padding and rendundancy, so a file with a size of 8192 bytes might be padded to 40 MiB and, with a redundancy of 5, encoded to 200 MiB for upload.")
  public Long getUploadedbytes() {
    return uploadedbytes;
  }

  public void setUploadedbytes(Long uploadedbytes) {
    this.uploadedbytes = uploadedbytes;
  }

  public FileInfo uploadprogress(BigDecimal uploadprogress) {
    this.uploadprogress = uploadprogress;
    return this;
  }

   /**
   * Percentage of the file uploaded, including redundancy. Uploading has completed when uploadprogress is 100. Files may be available for download before upload progress is 100.
   * @return uploadprogress
  **/
  @ApiModelProperty(example = "100.0", value = "Percentage of the file uploaded, including redundancy. Uploading has completed when uploadprogress is 100. Files may be available for download before upload progress is 100.")
  public BigDecimal getUploadprogress() {
    return uploadprogress;
  }

  public void setUploadprogress(BigDecimal uploadprogress) {
    this.uploadprogress = uploadprogress;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FileInfo fileInfo = (FileInfo) o;
    return Objects.equals(this.available, fileInfo.available) &&
        Objects.equals(this.expiration, fileInfo.expiration) &&
        Objects.equals(this.filesize, fileInfo.filesize) &&
        Objects.equals(this.localpath, fileInfo.localpath) &&
        Objects.equals(this.redundancy, fileInfo.redundancy) &&
        Objects.equals(this.renewing, fileInfo.renewing) &&
        Objects.equals(this.siapath, fileInfo.siapath) &&
        Objects.equals(this.uploadedbytes, fileInfo.uploadedbytes) &&
        Objects.equals(this.uploadprogress, fileInfo.uploadprogress);
  }

  @Override
  public int hashCode() {
    return Objects.hash(available, expiration, filesize, localpath, redundancy, renewing, siapath, uploadedbytes, uploadprogress);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FileInfo {\n");
    
    sb.append("    available: ").append(toIndentedString(available)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    filesize: ").append(toIndentedString(filesize)).append("\n");
    sb.append("    localpath: ").append(toIndentedString(localpath)).append("\n");
    sb.append("    redundancy: ").append(toIndentedString(redundancy)).append("\n");
    sb.append("    renewing: ").append(toIndentedString(renewing)).append("\n");
    sb.append("    siapath: ").append(toIndentedString(siapath)).append("\n");
    sb.append("    uploadedbytes: ").append(toIndentedString(uploadedbytes)).append("\n");
    sb.append("    uploadprogress: ").append(toIndentedString(uploadprogress)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

